name: Update tech badges

on:
  push:
    branches: ["**"]
  schedule:
    - cron: "0 9 * * 1" # Mondays 09:00 UTC
  workflow_dispatch:

permissions:
  contents: write

jobs:
  update-badges:
    runs-on: ubuntu-latest
    env:
      README_PATH: README.md
      SECTION_START: "<!-- TECH-STACK:START -->"
      SECTION_END: "<!-- TECH-STACK:END -->"
      BADGE_STYLE: "flat" # keep your current style
    steps:
      - uses: actions/checkout@v4
        with:
          persist-credentials: false

      - uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install Simple Icons (brand colors)
        run: npm i simple-icons@^13

      - name: Build tech stack section and update README
        run: |
          node - <<'NODE'
          const fs = require('fs');
          const path = require('path');

          const README_PATH   = process.env.README_PATH || 'README.md';
          const START_MARKER  = process.env.SECTION_START || '<!-- TECH-STACK:START -->';
          const END_MARKER    = process.env.SECTION_END   || '<!-- TECH-STACK:END -->';
          const BADGE_STYLE   = (process.env.BADGE_STYLE || 'flat').trim();

          if (!fs.existsSync(README_PATH)) {
            console.error(`‚ùå Missing ${README_PATH}`);
            process.exit(1);
          }

          // ---------- Your ALWAYS-SHOW badges (exact copies, grouped) ----------
          // Keep these EXACT so your look never changes.
          const BASE = {
            languages: [
              `<img src="https://img.shields.io/badge/JavaScript-F7DF1E.svg?style=flat&logo=JavaScript&logoColor=black" alt="JavaScript">`,
              `<img src="https://img.shields.io/badge/JSON-000000.svg?style=flat&logo=JSON&logoColor=white" alt="JSON">`,
              `<img src="https://img.shields.io/badge/Markdown-000000.svg?style=flat&logo=Markdown&logoColor=white" alt="Markdown">`,
            ],
            frameworks: [
              `<img src="https://img.shields.io/badge/Express-000000.svg?style=flat&logo=Express&logoColor=white" alt="Express">`,
              `<img src="https://img.shields.io/badge/Vue.js-4FC08D.svg?style=flat&logo=vuedotjs&logoColor=white" alt="Vue.js">`,
              `<img src="https://img.shields.io/badge/Bootstrap-7952B3.svg?style=flat&logo=Bootstrap&logoColor=white" alt="Bootstrap">`,
            ],
            databases: [
              `<img src="https://img.shields.io/badge/SQLite-003B57.svg?style=flat&logo=SQLite&logoColor=white" alt="SQLite">`,
            ],
            tools: [
              `<img src="https://img.shields.io/badge/npm-CB3837.svg?style=flat&logo=npm&logoColor=white" alt="npm">`,
              `<img src="https://img.shields.io/badge/Vite-646CFF.svg?style=flat&logo=Vite&logoColor=white" alt="Vite">`,
              `<img src="https://img.shields.io/badge/Nodemon-76D04B.svg?style=flat&logo=Nodemon&logoColor=white" alt="Nodemon">`,
              `<img src="https://img.shields.io/badge/Chai-A30701.svg?style=flat&logo=Chai&logoColor=white" alt="Chai">`,
              `<img src="https://img.shields.io/badge/Mocha-8D6748.svg?style=flat&logo=Mocha&logoColor=white" alt="Mocha">`,
            ],
          };

          // ---------- Helpers to detect additional tech from the repo ----------
          const IGNORE_DIRS = new Set(['.git','node_modules','dist','build','coverage','.next','.turbo','.cache','.venv','vendor','target','bin','obj']);
          const EXT_LANG = new Map(Object.entries({
            "js":"JavaScript","jsx":"JavaScript","mjs":"JavaScript",
            "ts":"TypeScript","tsx":"TypeScript",
            "html":"HTML5","htm":"HTML5",
            "css":"CSS3",
            "sql":"SQL"
          }));

          function normalizeLabel(s){ return String(s||'').toLowerCase().trim(); }

          async function walk(dir) {
            const out = [];
            const stack = [dir];
            while (stack.length) {
              const cur = stack.pop();
              const entries = fs.readdirSync(cur, { withFileTypes: true });
              for (const e of entries) {
                const p = path.join(cur, e.name);
                if (e.isDirectory()) {
                  if (!IGNORE_DIRS.has(e.name)) stack.push(p);
                } else if (e.isFile()) out.push(p);
              }
            }
            return out;
          }

          function readTextSafe(p){ try { return fs.readFileSync(p,'utf8'); } catch { return ''; } }
          function parseJSON(t){ try { return JSON.parse(t); } catch { return null; } }

          // Build a badge (HTML <img>) with brand color/logo where possible
          async function makeBadgeFactory() {
            const SI = await import('simple-icons');
            const preferWhiteLogo = (label) => true; // keep white logos for consistency

            function siLookup(label) {
              const variants = [
                label,
                label.replace(/\./g,'dot'),
                label.replace(/\s+/g,''),
                label.replace(/\+/g,'plus'),
                label.replace(/#/g,'sharp'),
                label.toLowerCase(),
              ];
              for (const v of variants) {
                const icon = SI.get?.(v) || SI.get?.(v.replace(/\s+/g,''));
                if (icon) return icon;
              }
              return null;
            }

            return (label, opts={}) => {
              const icon = siLookup(label);
              const hex = (opts.hex || icon?.hex || '444444').replace(/^#/, '');
              const logo = opts.logo || (icon ? encodeURIComponent(icon.slug) : undefined);
              const encLabel = encodeURIComponent(label);
              let url = `https://img.shields.io/badge/${encLabel}-${hex}.svg?style=${BADGE_STYLE}`;
              if (logo) url += `&logo=${logo}&logoColor=${preferWhiteLogo(label) ? 'white' : 'black'}`;
              return `<img src="${url}" alt="${label}">`;
            };
          }

          // Extract label from an <img ... alt="Label"> tag
          function labelFromImgTag(tag){
            const m = tag.match(/alt="([^"]+)"/i);
            return m ? m[1].trim() : null;
          }

          // Merge arrays of <img> tags by deduping on alt label
          function mergeUnique(existingTags, newTags){
            const seen = new Set(existingTags.map(labelFromImgTag).filter(Boolean).map(normalizeLabel));
            const add = [];
            for (const t of newTags){
              const l = normalizeLabel(labelFromImgTag(t));
              if (l && !seen.has(l)) { seen.add(l); add.push(t); }
            }
            return existingTags.concat(add);
          }

          (async () => {
            const makeBadge = await makeBadgeFactory();

            // 1) Start with your BASE (guaranteed)
            const buckets = {
              languages: [...BASE.languages],
              frameworks: [...BASE.frameworks],
              databases:  [...BASE.databases],
              tools:      [...BASE.tools],
            };

            // 2) Detect extra tech from package.json, Docker, etc.
            const files = await walk(process.cwd());
            const pkgPaths = files.filter(f => /(^|\/)package\.json$/i.test(f));

            const FW_MAP = {
              'express':'Express', 'vue':'Vue.js', 'bootstrap':'Bootstrap', 'vite':'Vite',
              'socket.io':'Socket.IO', 'axios':'Axios', 'cors':'CORS', 'dotenv':'dotenv', 'ws':'ws'
            };
            const DB_MAP = {
              'sqlite3':'SQLite', 'sqlite':'SQLite', 'mongoose':'Mongoose', 'mongodb':'MongoDB',
              'pg':'PostgreSQL', 'mysql':'MySQL', 'redis':'Redis'
            };
            const TOOL_MAP = {
              'mocha':'Mocha','chai':'Chai','jest':'Jest','vitest':'Vitest','cypress':'Cypress','playwright':'Playwright',
              'eslint':'ESLint','prettier':'Prettier','nodemon':'Nodemon','pm2':'PM2','nyc':'nyc/Istanbul'
            };

            const addBadges = (labels, group) => labels.map(l => makeBadge(l));

            for (const p of pkgPaths){
              const j = parseJSON(readTextSafe(p)) || {};
              const depBuckets = [j.dependencies,j.devDependencies,j.peerDependencies,j.optionalDependencies].filter(Boolean);
              for (const deps of depBuckets){
                for (const name of Object.keys(deps)){
                  const n = normalizeLabel(name);
                  if (FW_MAP[n])    buckets.frameworks = mergeUnique(buckets.frameworks, addBadges([FW_MAP[n]], 'frameworks'));
                  if (DB_MAP[n])    buckets.databases  = mergeUnique(buckets.databases,  addBadges([DB_MAP[n]], 'databases'));
                  if (TOOL_MAP[n])  buckets.tools      = mergeUnique(buckets.tools,      addBadges([TOOL_MAP[n]], 'tools'));
                  if (n === 'typescript') buckets.languages = mergeUnique(buckets.languages, addBadges(['TypeScript'],'languages'));
                }
              }
              // Scripts hints
              for (const s of Object.values(j.scripts || {})){
                const line = String(s).toLowerCase();
                if (/vite/.test(line)) buckets.frameworks = mergeUnique(buckets.frameworks, addBadges(['Vite'],'frameworks'));
                if (/eslint/.test(line)) buckets.tools = mergeUnique(buckets.tools, addBadges(['ESLint'],'tools'));
                if (/prettier/.test(line)) buckets.tools = mergeUnique(buckets.tools, addBadges(['Prettier'],'tools'));
              }
            }

            // Language detection by extensions (adds TypeScript/HTML/CSS/SQL if found)
            const langTotals = new Map();
            for (const f of files) {
              const ext = path.extname(f).slice(1).toLowerCase();
              const lang = EXT_LANG.get(ext);
              if (lang) langTotals.set(lang, (langTotals.get(lang)||0) + (fs.statSync(f).size || 0));
            }
            for (const lang of [...langTotals.keys()]) {
              buckets.languages = mergeUnique(buckets.languages, [ makeBadge(lang) ]);
            }

            // 3) Build ONE section with four categories (same as your headings)
            const section = [
              '',
              '### üß∞ Tech Stack',
              '',
              '**üë®‚Äçüíª Programming and Markup Languages**',
              buckets.languages.join('\n'),
              '<br>',
              '',
              '**üß∞ Frameworks and Libraries**',
              buckets.frameworks.join('\n'),
              '<br>',
              '',
              '**üóÑÔ∏è Databases and Cloud Hosting**',
              buckets.databases.join('\n'),
              '<br>',
              '',
              '**üíª Software and Tools**',
              buckets.tools.join('\n'),
              '',
            ].join('\n');

            // 4) Replace between markers
            let readme = fs.readFileSync(README_PATH,'utf8');
            const si = readme.indexOf(START_MARKER);
            const ei = readme.indexOf(END_MARKER);
            if (si === -1 || ei === -1 || ei < si) {
              console.error(`‚ùå Markers not found. Put:\n${START_MARKER}\n${END_MARKER}\ninto your README.md`);
              process.exit(1);
            }
            const before = readme.slice(0, si + START_MARKER.length);
            const after  = readme.slice(ei);
            const next = `${before}\n${section}\n${after}`;

            if (next === readme) {
              console.log('No changes.');
              process.exit(0);
            }
            fs.writeFileSync(README_PATH, next, 'utf8');
            console.log('‚úÖ README tech stack section updated.');
          })().catch(e => { console.error('‚ùå Failed:', e); process.exit(1); });
          NODE

      - name: Commit & push
        env:
          PAT_OR_TOKEN: ${{ secrets.PERSONAL_TOKEN || secrets.GITHUB_TOKEN }}
          README_PATH: README.md
        run: |
          if git diff --quiet -- "${README_PATH}"; then
            echo "No changes."
            exit 0
          fi
          git config user.name  "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add "${README_PATH}"
          git commit -m "chore: refresh Tech Stack badges (single-section, flat style)"
          git push https://x-access-token:${PAT_OR_TOKEN}@github.com/${GITHUB_REPOSITORY}.git HEAD:${GITHUB_REF_NAME:-main} || \
          git push https://x-access-token:${PAT_OR_TOKEN}@github.com/${GITHUB_REPOSITORY}.git HEAD:main || \
          git push https://x-access-token:${PAT_OR_TOKEN}@github.com/${GITHUB_REPOSITORY}.git HEAD:master
